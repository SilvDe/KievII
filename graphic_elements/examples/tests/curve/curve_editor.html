

<!DOCTYPE HTML>
<html>
  <head>
    <title>Curve Element test</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script type="text/javascript" src="../../../Element.js"></script>
    <script type="text/javascript" src="../../../UI.js"></script>
    <script type="text/javascript" src="../../../Curve.js"></script>
    <script type="text/javascript" src="../../../Background.js"></script>
    <script type="text/javascript" src="../../../wrappers/CanvasDraw.js"></script>
    <script type="text/javascript" src="../../../wrappers/Wrappers.js"></script>
    <script type="text/javascript" src="../../../../utilities/Utilities.js"></script>
    <script type="text/javascript" src="../../../../third_part/EightMedia-hammer.js/hammer.js"></script>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <script type="text/javascript">
    
    	var ui;
    	var plugin_canvas;
    	var CWrapper;
    	 
    	var appStatus = {
    		curveArray: [],
    		selected: null,
    		nextNumber: 0
    	}
    	
    	var pastEvent = new Date().getTime();
    	// millisecs
    	EVENT_DELAY = 200;
    	
    	Z_OFFSET = 0;
    	
    	var globalWidth = 800;
    	var globalHeight = 600;
    	
    	var lastCalculatedPoint = [];
    	
    	function clone(obj) {
		    // Handle the 3 simple types, and null or undefined
		    if (null == obj || "object" != typeof obj) return obj;
		
		    // Handle Date
		    if (obj instanceof Date) {
		        var copy = new Date();
		        copy.setTime(obj.getTime());
		        return copy;
		    }
		
		    // Handle Array
		    if (obj instanceof Array) {
		        var copy = [];
		        var len;
		        for (var i = 0, len = obj.length; i < len; ++i) {
		            copy[i] = clone(obj[i]);
		        }
		        return copy;
		    }
		
		    // Handle Object
		    if (obj instanceof Object) {
		        var copy = {};
		        for (var attr in obj) {
		            if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);
		        }
		        return copy;
		    }
		
		    throw new Error("Unable to copy obj! Its type isn't supported.");
		}
		
		var reorganizeElements = function (that) {
			var filter_func = function (value, connDetails) {
				// last point of the receiver is first point of the sender
				var recvPoints = clone(ui.getProp(connDetails.recv, 'values').points);
				var sendPoints = clone(ui.getProp(connDetails.sender, 'values').points);
				recvPoints [recvPoints.length - 1] = sendPoints[0];
				return recvPoints;
			}
			// Reset the connections
			ui.resetSlots();
			
			// Set the z-Indexes & the connections
			for (var i = 0; i < that.appStatus.curveArray.length; i +=1) {
				ui.setZIndex (that.appStatus.curveArray[i], i + Z_OFFSET);
				// If it's not the last curve, connect the next curve to this one
				if (i < that.appStatus.curveArray.length - 1) {
					ui.connectSlots (that.appStatus.curveArray[i+1], 'points', that.appStatus.curveArray[i], 'points', {'callback': filter_func});
				}
			}
		}
    	
    	// One callback for all
    	var callback = function () {
                var that = this;
                return function (slot, value, element) {
                    console.log ("Element: ", element, ". onValueSet callback: slot is ", slot, " and value is ", value, " while that is ", that);
                    if (slot === 'selected') {
                    	// See which element are we selecting
                    	for (var i = 0; i < that.appStatus.curveArray.length; i +=1) {
                    		if (that.appStatus.curveArray[i] === element) {
                    			ui.setProp (element, 'curveColor', 'red');
                    			that.appStatus.selected = i;
                    		}
                    		else {
                    			ui.setProp (that.appStatus.curveArray[i], 'curveColor', that.curveArgsTemplate.curveColor);
                    		}
                    	}
                    }
                    if (slot === 'held') {
                    	/* TODO maybe a context menu or something */
                    }
                    if (slot === 'doubletap_c') {
                    	/* Set the last point of the selected curve to x,y, then create another curve 
                    	 * and set its initial point to x,y, then its final point to the initial point of the next
                    	 * curve. Then insert the new curve in the right point of the array with splice() */
                    	
                    	 /* TODO Might want to check if two (or more) held events come with the same coordinates in a small
                    	 * amount of time (this happens when curves cross, or in the intersections)
                    	 */
                    	var now = new Date().getTime();
                    	if ((now - pastEvent) < EVENT_DELAY) {
                    		pastEvent = now;
                    		console.log ("Event arrived too short!");
                    		return;
                    	} 
                    	
                    	pastEvent = now;
                    	// PLEASE KEEP IN MIND that getProp does return a reference and not an hard copy! Be careful changing these values!
	        			var currentPoints = (ui.getProp (element, 'values')).points;
	        			
	        			// Get a deep copy of the template object
			        	var newCurveArgs = clone(that.curveArgsTemplate);
			        	
	        			// Linear by default (for now?)
			        	newCurveArgs.curveType = "linear";
        				newCurveArgs.ID = 'curve' + that.appStatus.nextNumber++;
        				
        				if (that.appStatus.selected < that.appStatus.curveArray.length - 1) {
        					newCurveArgs.paintTerminalPoints = 'first';
        					// The selected curve ends at the double-click value
        					currentPoints[currentPoints.length - 1] = value;
        					// Get the next curve
	        				var nextID = that.appStatus.curveArray[that.appStatus.selected + 1];
	        				var nextPoints = (ui.getProp (nextID, 'values')).points;
	        				// The new curve starts at the double-click value, ends at the first point of the next curve
	        				newCurveArgs.points = [value[0], value[1], nextPoints[0][0], nextPoints[0][1]];
        				}
        				
        				else {
        					// Set the former last curve's terminal points draw strategy as 'first' 
        					ui.setProp(element, 'paintTerminalPoints', 'first');
        					
        					newCurveArgs.paintTerminalPoints = 'all';
        					// Deep copy of the final object
        					var finalPoints = clone(currentPoints[currentPoints.length - 1]);
        					// The former last curve ends at the double-click value
        					currentPoints[currentPoints.length - 1] = value;
        					// The new last curve starts at the double-click value, ends at the former last points
        					newCurveArgs.points = [value[0], value[1], finalPoints[0], finalPoints[1]];
        				}
        				
        				var curveElement = new Curve(newCurveArgs);
      					ui.addElement(curveElement);
      					
      					that.appStatus.curveArray.splice(that.appStatus.selected + 1, 0, newCurveArgs.ID);
                    }
                    console.log ("Reorganizing elements");
                    reorganizeElements(that);
                    ui.refresh();
                };
        }();
    	
    	//curve template
        var curveArgsTemplate = {
            ID: "",
            top: 0,
            left: 0,
            width: globalWidth,
            height:globalHeight,
            thickness: 5,
            curveColor: "02B51F",
            handleColor: "A81B32",
            helperColor: "gray",
            curveLabels: true,
            midPointSize: 8,
            terminalPointSize: 15,
            terminalPointColor: 'black',
            terminalPointFill: '015C10',
            midPointFill: 'E6965A',
            isClickable: true,
            onValueSet: callback
        };
        
		function parseCurveType (frm) { 
			var curveType = null;
	        var grade = null;
	        	
	        	for (i = 0; i < frm.buttontype.length; i++) {
	      			if (frm.buttontype[i].checked) {
	         			curveType = frm.buttontype[i].value;
	      			}
	      		}
	      		
	      		if (curveType === null) curveType = 'linear';
	      		
	      		console.log ('Add: curve type is ' + curveType);
	      		
	      		if (curveType.indexOf('bezier') == 0) {
	      			var grade = parseInt(curveType.charAt(6), 10);
	      			curveType = 'bezier';
	      			console.log ("Curve is bezier and grade is " + grade);
	      		}
	      		
	      		return [curveType, grade];
      	}
        
        function clearCallback() {
        	for (var i = 0; i < this.appStatus.curveArray.length; i += 1) {
	        		// Remove the element from the UI
		        	ui.removeElement (this.appStatus.curveArray[i]);
		        }
		        // Remove the element from the array
		        this.appStatus.curveArray = [];
		        this.appStatus.selected = null;
		        ui.refresh();
        }
        
        function addCallback(frm) {
        	console.log ("Adding a curve");
        	
        	// Get a deep copy of the template object
        	// var newCurveArgs = JSON.parse(JSON.stringify(this.curveArgsTemplate));
        	var newCurveArgs = clone(this.curveArgsTemplate);
        	
        	newCurveArgs.ID = 'curve' + this.appStatus.nextNumber++;
        	
        	var argParse = parseCurveType(frm);
      		var curveType = newCurveArgs.curveType = argParse[0];
      		var bezierN = argParse[1];
      		
      		var firstPoint, lastPoint, midPoints = [];
      		
      		newCurveArgs.paintTerminalPoints = 'all';
      		// Calculate terminal points type and first, last point
      		if (this.appStatus.curveArray.length === 0) {
      			// Lower left
      			firstPoint = [0,this.globalHeight];
      		}
      		else {
      			// Appending: calculate the terminal point
	      		var lastElementID = this.appStatus.curveArray[this.appStatus.curveArray.length -1];
	      		//Get the values from the element
	      		var coordinates = (ui.getProp (lastElementID, 'values')).points;
	      		firstPoint = [coordinates[coordinates.length - 1][0], coordinates[coordinates.length - 1][1]];
	      		// Set the curve to paint only its first handle
	      		ui.setProp (lastElementID, 'paintTerminalPoints', 'first');
      		}
      		
      		var xInc = Math.round(globalWidth / 8);
      		var yInc = - Math.round(globalHeight / 8);
      		
      		// Calculate the next "landing" point
      		lastPoint = [firstPoint[0] + xInc, firstPoint[1] + yInc];
      		
      		if (lastPoint[0] > globalWidth) {
      			lastPoint[0] = globalWidth;
      		}
      		if (lastPoint[1] < 0) {
      			lastPoint[1] = 0;
      		}
      		
      		if ((lastPoint[0] === lastCalculatedPoint[0]) && (lastPoint[1] === lastCalculatedPoint[1])) {
      			// Set the curve to paint only its first handle
      			console.log ("Remove something before adding stuff");
      			// Undo the previous paintTerminalPoints inference
      			ui.setProp (lastElementID, 'paintTerminalPoints', 'all');
      			return;
      		}
      		
      		lastCalculatedPoint[0] = lastPoint[0];
      		lastCalculatedPoint[1] = lastPoint[1];
      		
      		switch (curveType) {
      			case 'linear':
      			case 'smooth':
      			case 'halfcosine':
      			// Two point curve
      			newCurveArgs.points = firstPoint.concat(lastPoint);
      			case 'bezier':
      			var midPoint = firstPoint.slice();
      			for (var i = 1; i < bezierN; i += 1) {
      				// TODO remove the magic numbers
      				midPoint[0] += 20;
      				midPoint[1] -= 20;
      				midPoints = midPoints.concat(midPoint);
      			}
      			newCurveArgs.points = firstPoint.concat(midPoints, lastPoint);
      		}
      		
      		var curveElement = new Curve(newCurveArgs);
      		ui.addElement(curveElement);
      		this.appStatus.curveArray.push(newCurveArgs.ID);
      		reorganizeElements(this);
      		ui.refresh();
        }
        
        function removeCallback() {
        	if (this.appStatus.selected !== null) {
	        	console.log ("Deleting selected curve " + this.appStatus.selected);

	        	//arr = arr.filter(function(){return true});
	        	
	        	// Change the (selected + 1) array initial point
	        	if ((this.appStatus.selected !== 0) && (this.appStatus.selected < this.appStatus.curveArray.length - 1)) {
	        		var nextID = this.appStatus.curveArray[this.appStatus.selected + 1];
	        		var prevID = this.appStatus.curveArray[this.appStatus.selected - 1];
	        		
	        		var nextValues = ui.getProp(nextID, 'values');
	        		var prevValues = ui.getProp(prevID, 'values');

					// PLEASE KEEP IN MIND that getProp does return a reference and not an hard copy! Be careful changing these values!
					// TODO maybe they should be cloned inside the UI (r/o copy)		        	
		        	var newValues = clone(nextValues);
		        	newValues.points[0][0] = prevValues.points[prevValues.points.length - 1][0];
		        	newValues.points[0][1] = prevValues.points[prevValues.points.length - 1][1];
		        	
		        	ui.setProp (nextID, 'values', newValues);
		        	
		        }
		        
		        if ((this.appStatus.selected === this.appStatus.curveArray.length - 1) && (this.appStatus.selected !== 0)){
		        		// Paint the final point in the previous curve
		        		var prevID = this.appStatus.curveArray[this.appStatus.selected - 1];
		        		ui.setProp (prevID, 'paintTerminalPoints', 'all');
		        	}
		        
		        // Remove the element from the UI
	        	ui.removeElement (this.appStatus.curveArray[this.appStatus.selected]);
		        
		        // Remove the element from the array
	        	this.appStatus.curveArray.splice(this.appStatus.selected, 1);
	        	
		        this.appStatus.selected = null;
		        
		        reorganizeElements(this);
		        ui.refresh();
	        }
        }
        
        function applyCallback(frm) {
        	if (this.appStatus.selected !== null) {
        		
        		var argParse = parseCurveType(frm);
        		
	        	console.log ("Transforming selected curve " + this.appStatus.selected);
	        	
	        	var curveType = argParse[0];
	        	var bezierN = argParse[1];
	        	
	        	var curveNow = ui.getProp (this.appStatus.curveArray[this.appStatus.selected], 'curveType');
	        	var curveValues = clone(ui.getProp (this.appStatus.curveArray[this.appStatus.selected], 'values'));
	        	var curvePoints = curveValues.points;
	        	var curveGrade = curvePoints.length - 1;
	        	
	        	if (curveNow === curveType) {
	        		if (curveType !== 'bezier') {
	        			console.log ("Identical type, doing nothing");
	        			return;
	        		}
	        		else {
	        			if (bezierN === curveGrade) {
	        				console.log ("Identical type and grade, doing nothing");
	        				return;
	        			}
	        		}
	        	}
	        	
	        	// We really have to change the curve
	        	// Take the first points
	        	var startPoint = curvePoints[0];
	        	var midPoints = [];
	        	var midPoint = [startPoint[0], startPoint[1]];
	        	// Calculate the midpoints, optionally
	        	if (curveType === 'bezier') {
		        	for (var i = 1; i < bezierN; i += 1) {
	      				// TODO remove the magic numbers
	      				midPoint[0] += 20;
	      				midPoint[1] -= 20;
	      				midPoints = midPoints.concat(midPoint);
	      			}
      			}
      			var endPoint = curvePoints[curvePoints.length - 1];
	        	var newPoints = startPoint.concat(midPoints, endPoint);
	        	
	        	//transform initial arguments into an {Array} of [x,y] coordinates
			    var newPointsCoordArray = [];
			    for(var i=0; i < newPoints.length; i = i + 2){
			        newPointsCoordArray.push([newPoints[i], newPoints[i+1]]);
			    }
	        	
	        	// set curveType and new points
	        	curveValues.points = newPointsCoordArray;
	        	ui.setProp (this.appStatus.curveArray[this.appStatus.selected], 'curveType', curveType);
	        	ui.setProp (this.appStatus.curveArray[this.appStatus.selected], 'values', curveValues);
	        	
	        	reorganizeElements(this);
	        	ui.refresh();
	        }
        }
          
        function init () {
            
            // Curve stuff
            var plugin_canvas = document.getElementById("plugin");

            var CWrapper = K2WRAPPER.createWrapper("CANVAS_WRAPPER",
                                                   {canvas: plugin_canvas}
                                                   );

            ui = new UI (plugin_canvas, CWrapper, {'breakOnFirstEvent': true});

        }
                
    </script>
    
  </head>
  <body onload="init()">
      <form action="">
		  <input type="radio" name="buttontype" value="linear" /> linear
	      <input type="radio" name="buttontype" value="halfcosine" /> halfcosine
	      <input type="radio" name="buttontype" value="smooth" /> smooth
	      <input type="radio" name="buttontype" value="bezier2" /> bezier2
	      <input type="radio" name="buttontype" value="bezier3" /> bezier3
	      <button id="addbutton" type="button" onclick="addCallback(this.form)">Add</button>
      	  <button id="removebutton" type="button" onclick="removeCallback()">Remove</button>
	      <button type="button" onclick="applyCallback(this.form)">Apply</button>
	      <button id="clearbutton" type="button" onclick="clearCallback()">CLEAR ALL</button>
	  </form>
      <canvas style="border: 1px solid gray;" id="plugin" width="800" height="600"></canvas>
  </body>
</html>
